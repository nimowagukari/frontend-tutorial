<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>オセロゲーム</title>
    <style>
        h1 {
            text-align: center;
        }

        table {
            border: 1px solid;
            border-collapse: collapse;
        }

        td {
            font-size: large;
            border: 1px solid;
            width: 50px;
            text-align: center;
        }

        tr {
            height: 50px;
        }

        .form {
            text-align: center;
            margin: 20px auto;
        }

        .message {
            margin: 0 auto;
            width: 400px;
            height: 60px;
            text-align: center;
        }
    </style>
</head>

<body>
    <h1>オセロゲーム</h1>
    <table align="center">
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td>●</td>
            <td>○</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td>○</td>
            <td>●</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <div class="form">
        <input type="button" value="開始する" onclick="startGame()">
    </div>
    <div class="message">
        <p id="yourStone"></p>
    </div>
    <script>
        let fieldCells = document.querySelectorAll("td");
        let cellMatrix = [];
        let cellsCanPut;
        let cPos;
        let rPos;
        let nowStone = "○";
        let yourStone = document.getElementById("yourStone");
        let button = document.querySelector("input");

        // 空のフィールド変数を作成
        for (r = 0; r < 8; r++) {
            cellMatrix.push([]);
        };

        // テーブルの各セルを二次元配列に格納
        for (let i = 0; i < fieldCells.length; i++) {
            cPos = i % 8;
            rPos = Math.floor(i / 8);
            cellMatrix[rPos][cPos] = fieldCells[i];
            cellMatrix[rPos][cPos].setAttribute("id", String(rPos) + "_" + String(cPos));
        };

        /*
        処理内容
        
        開始
        石を置ける場所をチェック
            自身と同じ色の石の位置を textContent から特定
            各石の周りに別の色の石があるかチェック
                ８方向の色をチェックし、
            別色の石がある方向の対面に石を置けるかチェック
        石を置ける場所をクリックして配置
            石を置ける場所にイベントを付与
                セル縁を太くしてわかるようにする
                マウスオーバしたら表示が変わる
                クリックしたら置かれる
        
        */

        // マウスオーバ処理
        function mouseOverOnCell(cell) {
            cell.target.textContent = nowStone;
            cell.target.style.background = "rgb(200,200,200)";
            cell.target.style.borderWidth = "5px";
        };
        function mouseLeaveFromCell(cell) {
            cell.target.textContent = "";
            cell.target.style.background = "rgb(255,255,255)";
            cell.target.style.borderWidth = "1px";
        };

        // 石配置処理
        function putStone(cell) {
            for (let c of cellsCanPut) {
                c.removeEventListener("mouseover", mouseOverOnCell);
                c.removeEventListener("mouseleave", mouseLeaveFromCell);
                c.removeEventListener("click", putStone);
            }
            cell.target.style.background = "rgb(255,255,255)";
            cell.target.style.borderWidth = "1px";
            cell.textContent = nowStone;
            toggleTurn();
            checkCellsCanPutStone();
        };

        function getAnotherStone(stone) {
            switch (stone) {
                case "●":
                    stone = "○";
                    break;
                case "○":
                    stone = "●";
                    break;
                default:
                    throw new Error("石がありません");
            };
            return stone;
        };

        function toggleTurn() {
            nowStone = getAnotherStone(nowStone);
            yourStone.textContent = `現在の石は ${nowStone} です`;
        };

        function selectCellsAround(cell, condition) {
            let cells = [];
            let pos = cell.id.split("_").map((v) => { return Number(v) });
            let rPos = pos[0];
            let cPos = pos[1];
            for (let r = rPos - 1; r <= rPos + 1; r++) {
                if (r < 0 || r > 7) {
                    continue;
                }
                for (let c = cPos - 1; c <= cPos + 1; c++) {
                    if (c < 0 || c > 7) {
                        continue;
                    };
                    if (c === cPos && r === rPos) {
                        continue;
                    };
                    switch (condition) {
                        case 'none':
                            if (cellMatrix[r][c].textContent === '') {
                                cells.push(cellMatrix[r][c]);
                            }
                            break;
                        case 'same':
                            if (cellMatrix[r][c].textContent === nowStone) {
                                cells.push(cellMatrix[r][c]);
                            }
                            break;
                        case 'another':
                            if (cellMatrix[r][c].textContent === getAnotherStone(nowStone)) {
                                cells.push(cellMatrix[r][c]);
                            }
                            break;
                        default:
                            cells.push(cellMatrix[r][c]);
                    }
                };
            };
            return cells;
        }

        function selectCellsOnAnotherStone() {
            let cell;
            let cells = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (cellMatrix[r][c].textContent === getAnotherStone(nowStone)) {
                        cell = cellMatrix[r][c];
                        cells.push(cell);
                    };
                };
            };
            return cells;
        };

        function selectEmptyCellsAround(cells) {
            let emptyCellsAround = new Set();
            let cellsAround;
            for (let c of cells) {
                cellsAround = selectCellsAround(c, 'none');
                for (let c2 of cellsAround) {
                    emptyCellsAround.add(c2);
                };
            };
            emptyCellsAround = Array.from(emptyCellsAround);
            return emptyCellsAround;
        };

        const DIRECTION = {
            UPPER_LEFT: 1,
            UP: 2,
            UPPER_RIGHT: 3,
            LEFT: 4,
            RIGHT: 5,
            LOWER_LEFT: 6,
            UNDER: 7,
            LOWER_RIGHT: 8
        }

        function getDirection(n1, n2) {
            let n1Pos = n1.id.split("_").map((v) => { return Number(v) });
            let n2Pos = n2.id.split("_").map((v) => { return Number(v) });
            let rMove = n2Pos[0] - n1Pos[0];
            let cMove = n2Pos[1] - n1Pos[1];
            let direction;
            if (rMove === 1) {
                switch (cMove) {
                    case 1:
                        direction = DIRECTION.LOWER_RIGHT;
                        break;
                    case 0:
                        direction = DIRECTION.UNDER;
                        break;
                    case -1:
                        direction = DIRECTION.LOWER_LEFT;
                        break;
                }
            } else if (rMove === 0) {
                switch (cMove) {
                    case 1:
                        direction = DIRECTION.RIGHT;
                        break;
                    case -1:
                        direction = DIRECTION.LEFT;
                        break;
                }
            } else if (rMove === -1) {
                switch (cMove) {
                    case 1:
                        direction = DIRECTION.UPPER_RIGHT;
                        break;
                    case 0:
                        direction = DIRECTION.UP;
                        break;
                    case -1:
                        direction = DIRECTION.UPPER_LEFT;
                        break;
                }
            } else {
                direction = null;
            }
            return direction
        }

        function moveCell(cell, direction) {
            let pos = cell.id.split("_").map((v) => { return Number(v) });
            let rPos = pos[0];
            let cPos = pos[1];
            let movedCell;
            switch (direction) {
                case DIRECTION.UPPER_LEFT:
                    movedCell = cellMatrix[rPos - 1][cPos - 1]
                    break;
                case DIRECTION.UPPER:
                    movedCell = cellMatrix[rPos - 1][cPos]
                    break;
                case DIRECTION.UPPER_RIGHT:
                    movedCell = cellMatrix[rPos - 1][cPos + 1]
                    break;
                case DIRECTION.LEFT:
                    movedCell = cellMatrix[rPos][cPos - 1]
                    break;
                case DIRECTION.RIGHT:
                    movedCell = cellMatrix[rPos][cPos + 1]
                    break;
                case DIRECTION.LOWER_LEFT:
                    movedCell = cellMatrix[rPos + 1][cPos - 1]
                    break;
                case DIRECTION.UNDER:
                    movedCell = cellMatrix[rPos + 1][cPos]
                    break;
                case DIRECTION.LOWER_RIGHT:
                    movedCell = cellMatrix[rPos + 1][cPos + 1]
                    break;
                default:
                    console.error("方向の指定が間違っています");
            }
            return movedCell;
        }

        function checkDirectionCanPutStone(from, direction) {
            let canPutStone;
            let to = moveCell(from, direction);
            switch (to.textContent) {
                case nowStone:
                    canPutStone = false;
                    break;
                case getAnotherStone(nowStone):
                    canPutStone = checkDirectionCanPutStone(to, direction);
                    break;
                case '':
                    canPutStone = true;
                    break;
                default:
                    console.error('石の状態がおかしいです')
            }
            return canPutStone;
        }

        function selectCellsCanPutStoneOppositeSide(cells) {
            let cellsCanPutStoneOppositeSide = new Set();
            let cellsAroundOnAnotherStone;
            for (let f of cells) {
                cellsAroundOnAnotherStone = selectCellsAround(f, 'another');
                for (let t of cellsAroundOnAnotherStone) {
                    direction = getDirection(f, t);
                    canPutStoneOppositeSide = checkDirectionCanPutStone(f, direction);
                    if (canPutStoneOppositeSide) {
                        cellsCanPutStoneOppositeSide.add(t);
                    }
                }
            }
            cellsCanPutStoneOppositeSide = Array.from(cellsCanPutStoneOppositeSide);
            return cellsCanPutStoneOppositeSide;
        };

        // function PutStoneOnCell() {

        // };

        // function turnOverStone() {

        // };

        function checkCellsCanPutStone() {
            let cells = selectCellsOnAnotherStone();
            cells = selectEmptyCellsAround(cells);
            cellsCanPut = selectCellsCanPutStoneOppositeSide(cells)
            // cellsCanPut = selectEmptyCellsAround(cells);
            if (cellsCanPut.length > 0) {
                for (let c of cellsCanPut) {
                    c.addEventListener("mouseover", mouseOverOnCell);
                    c.addEventListener("mouseleave", mouseLeaveFromCell);
                    c.addEventListener("click", putStone);
                };
            }
        };

        // ゲーム開始
        function startGame() {
            button.disabled = true;
            yourStone.textContent = `現在の石は ${nowStone} です`;
            checkCellsCanPutStone();
        };

    </script>
</body>

</html>